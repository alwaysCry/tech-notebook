# 类型转换及值的运算、比较

## 类型转换

### 基本类型间的转换

显/隐式类型转换的规则是一致的，显式即直接调用相应类型包装器：`String()`、`Number()`、`Boolean()`、`BigInt()`、`Symbol()`。另外`parseInt`、`parseFloat`等“提取”函数不在“转换”范畴

- 基本类型转 string，要点：

  - 二元加法运算若任一运算元为 string，则另一将转为 string

  - 除 symbol 外类型作为属性键时将转为 string

- 基本类型转 number，要点：

  <!-- - 一元加法会将运算元转为 number -->

  - 除了与 string 做二元加法外，参与所有数学运算的运算元都将先转为 number，失败了则为`NaN`

  - `undefined`->`NaN`、`null`->`0`、`true`->`1`、`false`->`0`

  - string 转 number 时会去除首尾空白字符（空格、`\n`、`\t`等），剩余：

    - 若仅有合法数字则取其数字

    - 若无其他字符则为`0`

    - 否则为`NaN`

- 基本类型转 boolean，要点：

  - `0`、空字符串、`null`、`undefined`、`NaN`将转为`false`

  - 其余值均对应`true`，包括`"0"`、`" "`（空格字符）等

### 对象转基本类型

对象转基本类型时有三种 hint（即方向暗示）：

- `"string"`，如当：显式调用`String(obj)`、alert 对象、作为属性的键时

- `"number"`，如当：显式调用`Number(obj)`、参与除二元加法外数学运算、大/小于比较、作为内置数学函数的入参时

- `"default"`，如当：参与二元加法（因其既可用于字符串连接，也可用于数字相加）、与字符串/数字/ Symbol 进行`==`比较时。（内建对象除 Date 外的`default`转换同`number`）

为进行转换，将按优先级尝试调用以下对象方法：

- `Symbol.toPrimitive`方法，其入参即 hint 值，且须返回原始类型，否则报错

- 否则若 hint 为`"string"`，则按优先级尝试调用`toString`或`valueOf`方法，方法须返回原始类型（但无须符合 hint），否则将被忽略（出于历史原因不报错）

- 否则若 hint 为`"number"`或`"default"`，则按优先级尝试调用`valueOf`或`valueOf`方法，其余同上

事实上：

- 除 Date 外多数对象的`valueOf`方法如未被覆盖，均会因未返回基本类型而被忽略

- 经前述得到的原始值并不一定符合 hint，因而可能还将再经一轮基本值转基本值

这也解释了以下情况：

```js
+[]; // 0  [].toString() -> "" ->Number("") -> 0
+[1]; // 1 [1].toString() -> "1" -> Number("1") -> 1
```

## 值的运算

参与运算的符号和值被称为**运算符**和**运算元**，且**所有运算符都会返回一个值**，其优先级[参见](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)

要点：

- 取余运算`a % b`的结果为`b`除以`a`的余数

- 求幂运算`a ** b`的结果为`a`的`b`次幂，且适用于非整数，如：`4 ** (1/2) === Math.sqrt(4)`

- 算术运算符中，除二元加法在任一运算元为 sting 时表现为字符串连接，其余情况运算元皆会转为 number 并返回 number 类型

- 自增/自减运算有前置（如`++n`）/后置（如`n++`）两种形式。区别在于前置**返回新值**，后置**返回原值**

- 所有算术/位运算符都有对应的“修改-赋值”运算符，如`+=`、`*=`等，其优先级与赋值运算符一致（相对靠后）

- 赋值运算`x = value`的本质为：将`value`写入`x`**再返回`value`**

- 链式赋值运算从右到左进行计算。例如`a = b = c = 2 + 2;`，先对表达式`2 + 2`求值，再将其依次赋给变量`c`、`b`、`a`，所有变量共享一个值

- 逗号运算符用于将表达式隔开，并返回最后一个的结果。因其优先级极低，所以常与圆括号配合使用

此外还有四个逻辑运算符：`||`（或）、`&&`（与）、`!`（非）、`??`（空值合并），要点：

- 或运算寻找并返回**第一个真值**，若无则返回最后一个值，返回值不会做布尔转换。据此特性可实现短路表达式，即当最后一个运算元为表达式（通常含副作用）时

- 与运算寻找并返回**第一个假值**，若无则返回最后一个值。其优先级高于或

- 非运算将值转为布尔类型并取反，若再取反（即`!!`）则将值转为对应布尔类型（等价于`Boolean()`）。其优先级为逻辑运算符中最高

- 空值合并运算（新特性）返回第一个非`null/undefined`值，若无则返回最后一个值。相比或运算，`0`、`false`、`""`均被视为有效值，因而更适于分配默认值。其优先级与或相同

## 值的比较

比较运算始终返回布尔值，主要可分为以下情况：

### 字符串间比较

两边按字符（不识别代理对）逐个比较其对应 **utf-16** 编码值：

1. 若一方较大或较小则直接返回结果

2. 否则（双方相等）各自取后一位进行比较

3. 重复上述步骤

4. 若双方字符同时用完则判定相等，否则未用完一方更大

### 不同类型值比较

不同类型值做比较时会先统一转为 number 类型，例外情况：

- 严格相等比较（`===`）以及严格不相等比较（`!==`）

- `null`或`undefined`在参与非严格相等/不相等比较时。例如：

  ```js
  null == 0; // false，不进行类型转换
  null >= 0; // true，null 会先转为 0
  ```

其他要点：

- `null`与`undefined`在非严格比较时相等，即`null == undefined`

- `NaN`与其他任何值（包括自身）在严格或非严格比较下均不相等。例如：

  ```js
  NaN == NaN; // false
  NaN === NaN; // false

  undefined > 0; // false
  undefined < 0; // false
  undefined == 0; // false
  ```
