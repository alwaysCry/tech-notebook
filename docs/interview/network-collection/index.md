# 面试题解析之网络

## A、B 机器正常连接后，B 机器突然重启，此时 A 处于 TCP 什么状态

### 定义

- A -> B 发起 TCP 请求，A 端为请求侧，B 端为服务侧
- TCP 三次握手已完成
- TCP 三次握手后双方没有任何数据交互
- B 在无预警情况下掉线（类似意外掉电重启状态）

### 答案

- 结论
  A 侧 TCP 链路状态在未发送任何数据情况下与等待时间相关，若在多个超时值范围内则状态为 `<established>`; 若触发了某一超时则视情况不同会有相应改变：

  一般情况，不管是 KeepAlive 还是内核超时，只要出现超时则必然抛出异常，只是后者被截获的时机会因编码方式差异而有所不同（如同步异步 IO，有无使用 select、poll、epoll 等 IO 多路复用机制等）

### 原因与相关细节

- **大前提**  
  基于 IP 网络的无状态特征，A 侧系统在无动作情况下不会收到任何通知，以获知到 B 侧掉线的情况 (除非 AB 是直连状态，则 A 可获知到自己网卡掉线的异常)

  在此大前提基础上，因链路环境、SOCKET 设定、及内核相关配置的不同，A 侧会在不同时机获知到 B 侧无响应的结果，但总归是以异常的形式

- **关于内核对待无数据传递 SOCKET 的方式**  
  操作系统有一堆时间级长的 timeout 参数（兜底用），用于在不同的时候给 TCP 栈一个异常退出的机会，避免无效连接过多而耗尽系统资源

  其中，`<TCP KeepAive>` 特性能让应用层配置一个远小于内核 timeout 参数的值，用于在这些长时间兜底参数生效前，判断链路是否为有效状态

- **关于超时的各个节点**  
  以下仅讨论三次握手成功之后的兜底情况

  TCP 链路建立后，内核会初始化一个由`<nf_conntrack_tcp_timeout_established>` 参数控制的计时器（该计时器在 Ubuntu 18.04 里面长达 5 天），以防止在未开启 TCP KeepAlive 情况下连接因各种原因导致的长时间无动作而过度消耗系统资源，该计时器会在每次 TCP 链路活动后重置

  TCP 正常传输过程中，每次数据发送后，必然伴随对端的 ACK 确认信息。若对端因各种原因失去反应（网络链路中断、意外掉电等）则 ACK 将永远不会到来，内核在每次发送后都会重置一个由 `<nf_conntrack_tcp_timeout_unacknowledged>` 参数控制的计时器，以防止对端以外断网导致的资源过度消耗（该计时器在 Ubuntu 18.04 里为 300 秒）

  以上两个计时器作为 keepalive 参数未指定情况下的兜底参数，是内核的自保特性，所以事件都很长，建议实际开发与运维中用更合理的参数覆盖这些数值

- **关于链路异常后发生的操作**  
  A 侧在超时退出后一般会发送一个 RST 包用于告知对端重置链路，并给应用层一个异常的状态信息。视乎同步 IO 与异步 IO 的差异，该异常获知时机会有所不同

  B 侧重启后，因为不存有之前 A-B 间链路相关信息，此时收到任何 A 侧来的数据都会以 RST 作为响应，以告知 A 侧链路发生异常

  RST 的设计用意在于链路发生意料外的故障时告知链路上的各方释放资源（一般指的是 NAT 网关与收发两端）; FIN 的设计是用于在链路正常情况下的正常单向终止与结束。二者不可混淆

- **关于阻塞**  
  应用层到底层网卡的发送过程中，数据包会经历多个缓冲区，也会经历一到多次的分片操作，阻塞作为一个结果，其发生具有从底向上传递的特性

  这一过程中有一个需强调的关键点：`socket.send` 操作只是把数据发送到了内核缓冲区，只要数据量不大则该调用必然是在拷贝完后立即返回的；而数据量大时，必然会产生阻塞。

  在 TCP 传输中，决定阻塞与否的最终节点，是 TCP 的可靠传输特性。此特性决定了必须要有 ACK 数据包回复响应正确接收的数据段范围，内核才会把对应数据从 TCP 发送缓冲区中移除，腾出空间让新数据可以写进来

  此过程意味着，只要应用层发送了大于内核缓冲区可容量的数据，则必然会在应用层出现阻塞：等待 ACK 的到来，再把新数据压入缓冲队列，循环往复直到数据发送完毕

## 永久性重定向（301）和临时性重定向（302）对 SEO 有什么影响

### 重定向的定义

服务器给浏览器一个状态码为 301 或 302 的重定向地址，将旧地址重定向到一个新地址，浏览器会自动跳转到 Location 头指定的 URL。需要的所有信息都在 HTTP 头，响应体一般是空的

### 重定向的目的

- **SEO**：若一个页面有两个地址如 `http://www.yy.com/` 和 `http://yy.com/`，搜索引擎会认为它们是两个网站，而造成每个搜索链接都减少从而降低排名；而同时，搜索引擎知道 301 永久重定向，会把两个访问地址归到同一网站排名下
- **缓存**：用不同地址会使缓存友好性变差，当一页面有多个域名时，其可能会被缓存好几次

### 相关状态码

- **301**：表示旧地址资源已被永久移除，搜索引擎在抓取新内容的同时也会将旧网站交换为重定向后的网址。适用场景：

  - 之前网站因某种原因要被移除，需到新地址访问，且是永久性的
  - 域名到期不想续费或发现了更适合的域名，想换
  - 空间服务器不稳定，而换空间时
  - 搜索引擎的结果中出现了不带 www 的域名，而带 www 的域名却没有收录，此时可用 301 重定向来告知引擎目标域名是哪一个

- **302**：表示旧地址的资源还在，只是临时从旧地址重定向至新地址。搜索引擎会抓取新的内容而保存旧的地址。适用场景：

  - 当一个网站或网页 24-48 小时内临时移动到一个新位置

结论：针对 SEO，301 更优

### 替代方案

- 若路径指向同一台服务器，可用 Alias 和 mod_rewrite
- 若是域名的变化，可创建一条 CNAME（创建一个指向另一域名的 DNS 记录作为别名），结合 Alias 或 mod_rewrite 指令
