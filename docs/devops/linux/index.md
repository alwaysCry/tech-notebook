# Linux 总结

## 总体概念

一切皆文件，包括各类硬件设备。常见设备在 linux 中对应的文件名:

- 硬盘（含 SCSI/SATA、USB 闪存等）：`/dev/sd[a-p]`

- VirtualI/O（主要在虚拟机中和云服务器中）：`/dev/vd[a-p]`

- 25 针打印机：`/dev/lp[0-2]`

- USB 打印机：`/dev/usb/lp[0-15]`

- 鼠标（通用）：`/dev/input/mouse[0-15]`

- 鼠标（当前）：`/dev/mouse`

- CDROM/DVDROM（通用）：`/dev/scd[0-1]`

- CDROM/DVDROM（CentOS）：`/dev/sr[0-1]`

- 当前 CDROM：`/dev/cdrom`

<!--
TODO:待归纳
- `/etc/passwd`: 记录系统上存在的各个账号
- `/etc/shadow`: 记录系统上各个账号的密码
- `/etc/group`: 记录系统上的各个组群
 -->

## 文件系统

- 分区（partition）：即 linux 中的`/dev/sd[a-p][1-...]`，对应 windows 下划分的 C、D、E ...盘符（虚拟机/云服务器等使用 VirtualI/O 的不在此列）

- 文件系统（filesystem）：操作系统间各不相同，linux 主要为 Ext 家族（Ext2/3/4）和 xfs

  - 可挂载文件通常被称为文件系统而非分区

  - 文件系统须挂载至目录树后方可被使用，挂载路径即为其入口。可通过`ll /lib/modules/$(uname -r)/kernel/fs`列出被当前操作系统支持的种类

<!-- linux 文件系统中有三类不同区块：

- superblock：记录此文件系统的整体咨询，包括 inode/block 的总量、使用量、剩余量以及文件系统的格式与相关资讯等
- inode：记录档案的属性，一个档案占用一个 inode，同时记录此档案内容所在的 block 号码;大小为 128bytes(ext2)，256bytes(ext4 与 xfs)
- block：实际记录档案的内容，若档案较大则会占用多个；每个 block 占用大小可为 1、2、4K（通常为 4K），可通过 dumpe2fs（ext 家族） 指令查询到

文件系统的 inode 与 block 基本上是固定的(除非重新格式化或使用 resize2fs 指令)
可以通过 dumpe2fs 指令加文件系统路径来获取 ext 家族文件系统的 superblock 信息
可以通过 blkid 指令来列出当前系统所有被挂载的块设备(?)，尤其是被格式化的文件系统(?)

从上可以总结出：

- 文件名并不是记录在文件自身的 inode 中，而是记录在文件所在的目录的 block 中（因而文件的新增、删除与重命名与其所在目录的 w 权限有关）
- 读取文件内容前会先通过文件所在目录的 inode 判断是否有该目录的 rx 权限（x 权限是必须的），有则找到该目录的 block，再通过 block 上找到目标文件 inode 号码找到目标文件的 inode
- 承上，通过文件的 inode 判断是否有文件的 r 权限，有则找到文件的 block 并读取其实际内容
- 承上，以上步骤从/目录开始递归执行

以下是新建文件的步骤：

1. 先确定是否有待新建文件所在目录的 wx 权限，有才能继续
2. 根据 inode bitmap 找到未使用的 inode 及其号码，并将新建文件的权限、属性写入
3. 更具 block bitmap 找到未使用的 block 号码，并将新建文件的实际资料写入，且更新 inode 中的 block 指向
4. 将 inode 与 block 的写入情况同步至 inode bitmap 与 block bitmap，并更新 superblock

一般我们将 inode table 与 data block 称为资料存放区，而 superblock、inode bitmap 与 block bitmap 则称为 metadata（中介资料）

早期 ext2 文件系统一旦在写入文件时因故中断而影响到更新 metadata，则可能出现其与实际资料存放区不一致的情况（inconsistent）,而解决方法则是使用 e2fsck 指令但相当费时。因此在 ext3/ext4 文件系统中规划出了一块日志记录区块，用于在写入文件前先记录待写入文件的资讯，等写入完成并更新完 metadata 后再完成该文件的记录。该种文件系统也被称为日志式文件系统，可以通过 dumpe2fs 在 spuerblock 中找到日志区域相关的资料

由于对硬盘的写入相比内存要慢,因此 linux 采用非同步处理（asynchronously）的方式，即对载入到内存的文件，若未被改动过，则标记其为干净的（clean）反之则为脏的（dirty）；系统会不定时将脏的资料写回磁盘以保持一致性，也可以使用 sync 指令，在正常关机时系统也会使用该指令；而不正常关机则让资料未回写入磁盘，而需要磁盘检查甚至导致文件系统的损毁 -->

<!-- 原则：文件名只与其所在目录有关，而文件内容则与文件 inode 有关； -->

<!-- 可通过`ll -i`列出指定文件的 inode 连结数 -->

## 链接

链接可分为：

- 硬链接（hard link）：实质为一个链接到 inode 的额外文件名，不增加磁盘空间和 inode 占用。特点是安全，删除任一文件名都不影响到其 inode 与 block，除非全部删除。但具有以下限制：

  - 不能跨文件系统

  - 不能（不推荐）为目录创建

- 软链接（symbolic link）：等同于 windows 下的快捷方式，具有自己的 inode 与 block，目标文件被删除时也随之失效

<!--

另外，在建立新目录`/[path]/[dirname]`时，实际上会多出：

- `/[path]/[dirname]`
- `/[path]/[dirname]/.`
- `/[path]/[dirname]/..`

由此可得，当建立一个新目录时，新目录的初始 link 数为 2，而其上层目录的 link 数会增加 1 -->

<!-- ### linux manual

可以通过 man 指令后接需要查询的指令名称来进入到该指令的说明书中（man page），当然实际并不止指令，man page 中可以包含不同类别内容的资料说明，通过数字划分：

- 1：可执行程序或 shell 命令
  (User-level commands and application)
- 2：系统呼叫（由核心提供的函数）
  (System calls and kernel error codes)
- 3：库函数
  (Library calls)
- 4：特殊文件（通常是在/dev 目录下的）
  (Device drivers and network protocols)
- 5: 文件格式或是协议设定（如一些.conf 文件）
  (Standard file formats)
- 6: 游戏
  (Games and demonstrations)
- 7: 各式各样的,如惯例与协定等,例如 Linux 文件系统,网络协定,ASCII code 等的说明
  (Miscellaneous files and documents)
- 8: 系统管理员所用(通常是专用)的指令
  (System administration commands)
- 9: 与核心有关的
  (Obscure kernel specs and interfaces)

要精确查询某个指令（也有可能以上类别对象）的类别和简要说明，用 whatis 指令，等价于 man -f；若要模糊查询并列出匹配项则用 apropos 指令，等价于 man -k；以上效用的基础是建立 whatis 资料库，可用 mandb 指令重新建立 -->

## 文件类型

- `d`：目录
- `-`：普通档案
- `l`：链接
- `b`：块设备
- `c`：字符设备
- `p`：管道
- `s`：套接字

## 文件权限

每个文件都有拥有者和所属群组属性，因而其权限分三组：拥有者权限、所属群组用户权限、其他用户权限，每组又由`rwx`这三者组成（若不具有则记为`-`）：

- `r`：可读（read）

- `w`：可写（write），即编辑该文件的内容但**不包括删除**

- `x`：可执行（execute）

对于目录而言，`r`、`w`、`x` 的意义有所不同：

- `r`：可读取目录结构、查询其下文件资料（如`ls`或 tab 键路径补齐）

- `w`：可改变目录结构，相关操作：

  - 新建文件
  - 删除文件（注：无需拥有该文件的权限）
  - 移动（重命名）文件（如跨目录则还需拥有目标目录的权限）

- `x`：可进入该目录，**也是其下文件被执行或参与执行的前提**

相关实例：

- 开放目录供人浏览，则至少应开放其`rx`权限

- 读取文件内容需文件的`r`权限及其所在目录的`x`权限

- 修改文件内容需文件的`rw`权限及其所在目录的`x`权限

- 执行文件或使其参与执行，则需文件的`rx`权限及其所在目录的`x`权限

- 删除文件只需其所在目录的`wx`权限

- 将文件复制到另一目录中，则需文件的`r`权限、其所在目录的`x`权限及目标目录的`wx`权限

## 文件的变更时间

文件有以下三个变更时间：

- mtime（modification time）：修改时间，在文件内容变更时更新

- ctime（status time）：属性变更时间，在文件权限或属性变更时更新

- atime（access time）：访问时间，在文件内容被读取时更新

默认下，`ll`展示的是文件的 mtime，可以通过`--time=[atime/ctime]`选项调整；也可以通过 `touch`来改变上述时间

<!-- ## 打包压缩

- 打包：使用`tar`命令将多个文件或目录整合成一个后缀为`.tar`的文件，且后者通常会被进一步压缩

- 压缩：仅针对单个文件压缩其体积，常用压缩命令及其关联后缀有：`gzip（.gz）`、`xz（.xz）`、`bzip2（.bz2）`
 -->

<!-- 一些 linux 下常见的压缩文件后缀：

- .Z：compress 程序压缩后的文件
- .zip：zip 程序压缩后的文件
- .gz：gzip 程序压缩后的文件
- .bz2：bzip2 程序压缩后的文件
- .xz：xz 程序压缩后的文件
- .tar：tar 程序打包后的文件，未经压缩
- .tar.gz：tar 程序打包后的文件，并经过 gzip 的压缩
- .tar.bz2：tar 程序打包后的文件，并经过 bzip2 的压缩
- .tar.xz：tar 程序打包后的文件，并经过 xz 的压缩

linux 上常用的（解）压缩指令（压缩而非打包，只能针对单个文件）：

- gizp: 默认压缩文件后缀为.gz，也能兼容 compress,zip 程序，一些用法：
  - `gzip`:默认下生成给定文件的压缩文件，同时原文件被删除，-v 选项可以输出压缩比，-d 选项用于指定解压缩
  - `gzip -c [file] > [file].gz`：生成压缩文件，并保留原文件
  - 若原文件为文本文件，则可以使用 zcat/zmore/zless 来直接读取其压缩文件的文本内容
  - 同理，可以使用 zgrep 来搜索其文本内容，而无需先解压缩
- bzip2：压缩后缀为.bz2，用法基本与 gzip 相同，而压缩率更好但压缩速度也更慢
- xz：压缩后缀为.xz, 压缩比更好，速度也更慢，用法稍有区别:
  - `xz`：默认下生成压缩文件并删除源文件，但可以通过 -k 选项保留；-d、-v 选项作用与 gzip 一致；-l 选项用于获取压缩后文件的信息

将多个文件或目录整合成一个文件，称之为打包；linux 中 tar 指令用于打包，其产物被称为 tar 包，同时可以通过 gzip/bzip2/xz 的支持对其进行压缩，其用法如下：

- -f 选项后接路径用于在加压/解压中指定相应的 tar 包（dirname/basename）
- -c 选用于指定建立 tar 包，可搭配 -v 来查看过程中被打包的文件名
- -t 用于查看 tar 包内包含的文件名
- -x 用于指定解包或解压缩，可搭配 -C 后接参数来指定在特定目录解开
- 承上，-c、-t、-x 不可同时出现
- -z 借助 gzip 的支持对 tar 包进行压缩/解压缩，此时推荐文件后缀为 .tar.gz
- -j 借助 bzip2 的支持对 tar 包进行压缩/解压缩，此时推荐文件后缀为 .tar.bz2
- -J 借助 xz 的支持对 tar 包进行压缩/解压缩，此时推荐文件后缀为 .tar.xz
- 承上，-z、-j、-J 不可同时出现
- -p 选项用于保留被打包文件原本的权限与属性
- -P 选项用于保留绝对路径，即允许 tar 包中含有根目录存在，即解包后以绝对路径生成文件，因而有可能会覆盖原始文件
- --exclude=[filename] 打包过程中排除指定文件
- 例子，`tar -ztv -f ./etc.tar.gz | grep 'shadow'`：查找当前目录下的 tar 包 gzip 压缩包内名称包含 shadow 的文件
- 例子，`tar -zxv -f ./etc.tar.gz etc/shadow`：单独解包出 etc/shadow 文件
- 例子，`tar -zcv -f ./etc.tar.gz --newer-mtime="2015/06/17" /etc/*`: 将/etc 目录下 mtime 在 2015/06/17 之后的文件(以及全部的目录)打包；这里需要注意目录依旧会被打包进去
- 例子，`tar -cvf - /etc | tar -xvf -`：这是最特殊的，即通过管道命令来实现边打包边解压缩到当前目录，与 cp -r 类似但没有中间文件存在

综上补充，一般经 tar 打包但未被压缩的称之为 tarfile，如已被压缩则称为 tarball -->

<!-- #### zip/unzip 命令

zip/unzip 命令分别用于压缩/解压缩 zip 格式压缩文件

zip 命令大致用法 `zip [options] [zipfile] [...file]`,参数解析:

- -r: 递归压缩目录
- -m: 将文件压缩后删除原始文件
- -[level]: 指定 1-9 的压缩级别,越大压缩级别越好,压缩速度越慢
- -u: 更新模式,即往已有压缩文件中添加新文件

unzip 命令默认将指定 zip 文件解压至当前目录下,大致用法 `zip [options] [zipfile]`,参数解析:

- -d: 后接 path,用于手动指定解压目录
- -x: 后接 path 列表,用于排除待解压的文件
- -o: 解压时覆盖已存在文件
- -t: 仅测试压缩文件有无损坏
- -l: 仅列出压缩文件中包含的文件 -->

<!-- ## Linux 账号与群组

本质上 linux 系统识别的并非用户名而是 ID，每个用户至少会有两个 ID：

- UID（User ID），用户 ID，其中又分三类：
  - 系统管理员（root）：UID 为 0，且可将其给予其他用户，使其具有 root 权限
  - 系统用户：UID 取 1~999，其中又可细分为，1~200：linux 各发行版自行建立的系统用户；201~999：其他自建系统用户
  - 一般用户：UID 取 1000~60000
- GID（Group ID），群组 ID；用户可以加入多个群组，且在读取/写入/执行文件时，户用拥有所有所在群组的权限；群组同样可分为系统群组和一般群组（详见/etc/login.defs）；此外群组可分为：
  - 初始群组（initial group）：即/etc/passwd 内记载的（每行第四栏），也是用户一登入系统便所在的群组；该群组的用户不会记载在/etc/group 内（每行第四栏），而此外的其他群组成员均会被记载；
  - 有效群组（effective group）：即输入 groups 指令时列出的第一个群组，也是用户所新建文件的所在群组

### linux 账号管理

**使用 useradd 指令新建用户**，其使用选项如下：

- -u：后接数字来手动指定 UID
- -g：后接群组名称来指定初始群组（默认与用户名相同）
- -G：后接群组名称来指定其加入的其他群组
- -M：不建立专属 home 目录（建立系统用户时预设）
- -m：会建立专属 home 目录（建立一般用户时预设）
- -c：后接对该用户的说明内容（会出现在/etc/passwd 每行的第 5 栏）
- -d：后接目录以指定该用户的专属 home 目录（否则会有默认值，务必使用绝对路径，默认权限 700）
- -e：后接并指定账号失效日期
- -s：后接并指定用户登录的 shell（默认则如 /etc/default/useradd 中所指定，bash）
- -r：指定建立系统用户，其 UID 设定会有所限制（详见 /etc/login.defs）
- -D: 输出预设配置（即 /etc/default/useradd 内容）

注意新建账号会被暂时封锁而无法登入，需要使用 passwd 指令为其设立密码（存疑，一般用户？）

**使用 usermod 指令修改用户设置**，其选项多与 useradd 相似，以下一些列举：

- -g：后接名称用于修改用户初始群组
- -G：后接名称用于重设用户所在一般群组
- -a：须在 -G 选项前指定，用于新增用户所在群组，如 `usermod -aG newusers young.penn`
- -l：后接名称用于修改用户名
- -L/-U：锁定/解锁指定用户，作用与 passwd 指令的-l/-u 选项相同

**使用 passwd 指令给指定用户设立或修改密码**（若未指定用户名则给自己）；其常用选项如下：

- --stdin：指定从标准输入中获取密码，而非默认的交互模式
- -l：即 lock 的意思，后接用户名，其实质是在 /etc/shadow 第二栏经加密后的密码字符前加!前缀使其变得不合法，使该用户无法使用密码登录（还可以用其他方式诸如 ssh 公钥）；该操作只限 root 用户；lock 状态可以经由 `passwd -S [用户名]` 获知
- -u：即 unlock，后接用户名使其解除 lock 状态
- -S：后接用户名，列出其密码相关的资讯
- **还有密码时效相关选项......**

注意普通用户只能修改自己的密码，且需要先输入现有密码做确认，并会经 PAM 模组来做安全性检查，过于简单或不规范的密码会被拒绝；而 root

**使用 userdel 指令来删除用户**，用法大致如：`userdel [-r] username`；可以指定 -r 选项来连同删除其 home 目录，另外若要将某账号完整移除，建议在使用该指令前以 `find / -user username` 指令找出所有属于其的文件并删除；若只是暂时不启用该账号，则可将/etc/shadow 对应行的账号失效日期（第八栏）设为 0

**使用 id 指令查询自己或其他用户的 UID、GID、所在群组等信息**

### linux 群组管理

**使用 groupadd 指令新建群组**，其用法大致为 `groupadd [-g gid] [-r] 群组名称`，选项说明如下：

- -g：用于手动指定 GID
- -r：指定建立系统群组

**使用 groupmod 指令来修改群组**，其用法大致为 `groupmod [-g gid] [-n groupname] 群组名`，其中 -g 选择用于指定修改 GID，-n 则用于指定修改群组名；建议不要随意变更群组的 GID

**使用 groups 指令查询指定用户所在群组**，用法大致如 `groups root`；其中展示的第一个即为该用户的有效群组

**使用 groupdel 指令删除群组**，前提是该群组不是某个用户的初始群组（即该群组的 GID 未出现在 /etc/passwd 中），否则需要先修改该用户的初始群组或删除该用户

**使用 newgrp 指令切换有效群组**，该指令会打开一个子 shell，在其中用户的有效群组被改为指定组（只能是用户所在的群组之一）；输入 exit 指令退出后会还原此设置

### linux 身份切换

很多情况下，linux 使用者有切换身份的需求，如以一般用户的身份做日常操作，以 root 身份做系统管理或以较低权限启动系统服务；基于上述考量，有以下两种方式做身份切换：

- 使用 su 指令直接切换账号并登入到新的 shell 中，并可以 exit 指令返回;该指令的大致用法如：`su [-lm] [-c 指令] [username]`；若不指定用户名则切换至 root，默认会以 non-login shell 的方式登入，导致很多环境变量未改变；需要选项为：
  - -l：或直接以-表示，意为以 login shell 方式登入
  - -m/-p：以保留原有环境的方式切换新用户登入（不读取新用户的配置文件）
  - -c：仅执行一次指令，完毕后返回原有身份（无需 exit），因而该命令可以后接指令，如：`su - -c "head -n 3 /etc/shadow"`
- 使用 sudo 指令以其他用户的身份执行指令（通常是 root）；与 su 指令相比有个好处是能以系统账号的身份执行指令（系统账号的 shell 为/sbin/nologin）；当然并非所有用户都能执行 sudo，而是需要在 /etc/sudoers 内的才可以，且需输入当前用户自己的密码来确认（root 除外）；其用法大致为：`sudo [-b] [-u 新用户账号] 待执行指令`，而常用选项为：
  - -b：将后续指令放到背景中执行而不会与目前 shell 产生影响
  - -u：后接欲切换的使用者，若无则默认以 root 身份执行

### 关于 /etc/sudoers

承上文，/etc/sudoers 文件记录了能够使用 sudo 指令的用户及其被授权使用的指令等，因其遵循一定的语法，因此推荐使用 visudo 指令去修改；一些用法详解如下：

- 使单一用户能执行 root 的所有指令：

  ```bash
  ...
  root ALL=(ALL) ALL
  # 在其下新增一行
  # 从左到右意义分别为：使用者账号  登入着来源主机名称=(可切换身份) 可下达的指令（绝对路径）
  young.penn ALL=(ALL) ALL
  ...
  ```

- 使某一群组内的用户能执行 root 的所有指令：

  ```bash
  ...
  %wheel ALL=(ALL) ALL
  # 在其下新增一行
  # 开头的%即表示群组之意
  %newusers ALL=(ALL) ALL
  # 若需免密使用sudo，则可改为：
  # %newusers ALL=(ALL) NOPASSWD:ALL
  ...
  ```

- 有限制的指令操作：

  ```bash
  # 在最后一栏用绝对路径列出可操作的指令，多个可用逗号(,)隔开
  young.penn ALL=(root) /bin/passwd
  # 也可进一步限制参数的使用, 以下指令中!表示不可执行，即可调用passwd但无法修改root的密码
  # young.penn ALL=(root) !/bin/passwd, /bin/passwd [A-Za-z]*, !/bin/passwd root
  ```

- 使用别名

  ```bash
  # 以下使用了账号别名和指令别名，此外还有主机别名等
  User_Alias ADMPW=pro1, pro1, pro3, myuser1, myuser2
  Cmnd_Alias ADMPWCOM=!/bin/passwd, /bin/passwd [A-Za-z]*, !/bin/passwd root
  ADMPW ALL=(root) ADMPWCOM
  ```

- 使用 sudo 调用 su -：

  ```bash
  # 该种方式的有点是利用su取得root身份，但root密码不会外流
  User_Alias ADMINS=pro1, pro2, pro3, myuser1
  ADMINS ALL=(root) /bin/su -
  ```
 -->

## 定时任务

定时任务可通过以下方式实现

<!-- （不带选择或仅带-m）输入前者后会进入一个 at shell 环境来下达工作指令（将要在未来执行的），并以 ctrl + d 结束； -->

### at

`at <TIME>`用于设置一次性定时任务。后台 atd 服务会在每分钟的第 0 秒做一次检查，且不会有任何任务相关的标准（或错误）输出，但可设置以邮件告知。其时间参数格式如下：

- `<HH>:<MM>`（已过期则安排在明天）

- `<HH>:<MM> <YYYY>-<MM>-<DD>`

- `<HH>:<MM>[am|pm] <Month> <Date>`

- `<HH>:<MM>[am|pm]+<number> [minutes|hours|days|weeks]`（某个时间点的某段时间后）

- `now+<number> [minutes|hours|days|weeks]`

常用选项如下：

- `-m`：任务完成后以邮件形式通知

- `-l`：相当于执行`atq`，列出所有正在排期的任务

- `-d <job-id>`：相当于执行`atrm`，取消指定任务

- `-c <jobId>`：输出指定任务的详细信息

### crontab（cron table）

`crontab`用于建立用户级定时任务，相关任务会被记录在`/var/spool/cron/<username>` 中，具体目录取决于该任务归属的用户，默认为 root。常用选项：

- `-u <username>`：指定本次编辑/查看的定时任务的归属用户（默认当前用户），该选项只限 root 指定

- `-e`：进入一个 vi 界面来编辑 crontab 的任务内容

- `-l`：列出当前 crontab 内容

- `-r`：移除所有 crontab 内容

关于 crontab 的语法， 其每行（每项）有六个栏位，意义如下：

|      | 分钟 | 小时 | 日期 | 月份 | 周（与日/月不可共存）  | 指令 |
| ---- | ---- | ---- | ---- | ---- | :--------------------: | :--: |
| 范围 | 0-59 | 0-23 | 1-31 | 1-12 | 0-7（0、7 均代表周日） |  -   |

此外还可输入以下辅助字符：

- `*`：表示任何时刻都可接受。如于每日 12:00 执行相关指令，`0 12 * * * <command>`

- `.`：用于分隔时段。如于每日的 3:00 和 6:00 执行相关指令，`0 3,6 * * * <command>`

- `-`：表示时间范围。如于每日 8:00-12:00 间的每小时第 20 分执行指令，`20 8-12 * * * <command>`

- `/<n>`：表示每隔 n 个时间单位，如每 5 分钟执行一次指令，`*/5 * * * * <command>`

除用户级外，还有系统级和应用级定时任务。其 cron 文件格式与前者大同小异，除了在指令栏前增加了任务调用者身份栏（一般为 root）

  <!--
  以及以下几项位于开头的声明：
  ```sh
  SHELL=/bin/bash
  PATH=/sbin:/bin:/usr/sbin:
  # 任务产生标准（错误）输出的发送邮箱
  MAILTO=...
  ```
  -->

- 系统级定时任务被记录于`/etc/crontab`

- 各应用级定时任务被记录于`/etc/cron.d/*`（方便覆盖）

此外还可直接将 shell 脚本置于`/etc/cron.hourly`目录下，其中脚本会在每小时的前 5 分内择时执行。该机制通过定时调用 run-parts 脚本现实，该定时任务记录于`/etc/cron.d/0hourly`中

<!-- 另一个与 at 相关的是 batch 指令，指令用法与 at 大致相似但不支持时间参数，而是在 CPU 工作负载小于 0.8 时执行排期任务；其任务列表同样可以通过 at -l 或 atq 查到
关于 CPU 工作负载：可以通过 uptime 查到，与当前 CPU 同时执行的任务数有关（即 CPU 要在多少个工作间切换），以下是一个体现的例子：

```shell
同时在后台执行多个计算pi的任务
[root@study ~]# echo "scale=100000; 4*a(1)" | bc -lq &
[root@study ~]# echo "scale=100000; 4*a(1)" | bc -lq &
[root@study ~]# echo "scale=100000; 4*a(1)" | bc -lq &
[root@study ~]# echo "scale=100000; 4*a(1)" | bc -lq &
等待十来秒后，使用uptime指令查看工作负载情况，列出的是1、5、15分钟的平均工作负载
[root@study ~]# uptime
19:56:45 up 2 days, 19:54,  2 users,  load average: 3.93, 2.23, 0.96
通过jobs指令同样可以观察到正在后台执行任务
[root@study ~]# jobs
[1]   Running                 echo "scale=100000; 4*a(1)" | bc -lq &
[2]   Running                 echo "scale=100000; 4*a(1)" | bc -lq &
[3]-  Running                 echo "scale=100000; 4*a(1)" | bc -lq &
[4]+  Running                 echo "scale=100000; 4*a(1)" | bc -lq &
杀掉这些任务
kill -9 %1 %2 %3 %4
等待一段时间后再次调用uptime，可以观察到工作负载下降了
[root@study ~]# uptime
20:01:33 up 2 days, 19:59,  2 users,  load average: 0.89, 2.29, 1.40
``` -->

<!-- TODO：## linux anacron 指令 -->

## 进程管理

进程（process）是被执行的程序，具有独立的 PID。要点：

<!-- 执行者的权限与属性、程序的程序码等都会被载入内存中，操作系统会给予该内存内的单元一个识别码（PID） -->

- 所有进程都是 systemd 进程（PID 为 1）的子进程

- 子进程将沿用父进程的相关权限属性，并将其 PID 记录于自身的 PPID 中

- 杀死父进程将导致其所有子进程被杀死

- 已执行完毕或因故应被终止的子进程无法完整地被父进程结束掉时，即成为僵尸进程而一直存于内存中。后者会在 PS 命令输出的 CMD/COMMAND 列中带有`<defunct>`标识

<!-- 而之所以遇到僵尸进程需要重新开机，也是因为 systemd 要重新启动，而重新启动 systemd 就是 reboot
 -->

<!-- 综上，举例来说，/bin/bash 就是一个程序；而用户登入后使用的操作的 bash shell 则是一个进程，具有独立的 PID 和源操作用户的 User/Group 属性，而其上衍生出的其他程序（如其中执行的指令）均是该 bash 进程的子进程，并会沿用它的相关权限属性；另外，杀死父进程也将导致其所有子进程被杀死；
如上所述，进程中执行的程序（或指令）是该进程的子进程，其 PPID 即为父进程的 PID（可以通过 `ps -l` 查知），子进程可以获得父进程的环境变量； -->

### ps

`ps`命令用于获取当前进程快照，该指令通常只需记住以下用法：

- `ps -l`：列出当前 shell 进程及其子进程，相关字段含义如下：

  - `F`：进程标识（process flags），<!-- 即该进程的总结权限， -->主要值：

    - `4`：表示该进程的权限为 root

    - `1`：表示该进程仅进行复制（fork）而未实际执行（exec）

  - `S`：进程状态，主要值：

    - `R`（Running）：运行中
    - `S`（Sleep）：睡眠状态，但可被唤醒
    - `D`：不可被唤醒的睡眠，通常可能在等待 I/O 的情况
    - `T`：停止状态（stop），可能是在工作控制中的后台暂停或出错（traced）状态
    - `Z`（Zombie）：僵尸状态，进程已被终止但无法从内存中移除

  - `UID` / `PID` / `PPID`：进程拥有者的 UID / 进程自身的 PID / 其父进程的 PID

  - `C`：CPU 使用率，单位为百分比

  - `PRI`（Priority / `NI`（Nice）：进程被 CPU 执行的优先级顺序，数值越小优先级越高

  - `ADDR`：进程在内存中的所在部分，running 进程一般会显示 `-`

  - `SZ`：进程占用的内存

  - `WCHAN`：当前进程是否在运行中，`-`表示运行中

  - `TTY`：登入者的终端机位置，远程登入的为`pts\<n>`（n 为数字）

  - `TIME`：进程实际花费的 CPU 运作时间

  - `CMD`：触发此进程的指令

- `ps -lA`：其输出格式与`ps -l`相同，但会包含系统内所有进程

- `ps aux`：列出当前系统下的所有进程（注意此处无`-`），相关字段含义如下：

  - `USER`：进程的归属用户
  - `PID`：进程 PID
  - `%CPU`：进程使用的 CPU 资源占比
  - `%MEM`：进程使用的内存占比
  - `VSZ`：进程使用的虚拟内存量（Kbytes）
  - `RSS`：进程使用的固定内存量（Kbytes）
  - `TTY`：进程是通过哪个终端机启动的，常见值：
    - `?`：与终端机无关
    - `tty1`-`tty6`：表示本机上的登入者程序
    - `pts/0`：表示由网络连接主机的程序
  - `STAT`：进程状态，其值与`ps -l`的`S`栏意义相同
  - `START`：进程启动时间
  - `TIME`：进程的 CPU 运作时间
  - `COMMAND`：进程对应的实际指令

- `ps axjf`：以进程树格式输出，功能与 pstree 命令类似

### top

相较于 ps 命令截取当前时间点的进程快照。top 命令可持续监测进程状态，其常用选项如下：

- `-d <seconds>`：指定更新间隔，默认为 5 秒

- `-b`：以流式而非更新的方式输出每次进程状态变化，常搭配重定向来将其输出导入至文件

- `-n <num>`：与`-b`搭配，指定输出进程状态变化的次数，完成后退出

- `-p <PID>`：监测指定进程

其界面分为上下部分。上半部分作为总体概览共六行，依次为：

- `top`，依次列出：当前时间、开机时长、登入系统人数、1/5/15 分钟的平均工作负载（同 uptime 命令）

- `Tasks`，列出当前进程总数，以及各个状态下（running/sleeping/stopped/zombie）的进程数

- `%Cpus(s)`，列出 CPU 的整体负载（需特别注意 wa 列，代表 I/O wait，系统性能问题通常来自于 I/O）。若为多核 CPU，还可按下数字键 1 来分行展示各个核心的负载率

- `KiB Mem`和`Swap`行分别表示当前实体内存和虚拟内存的使用情况。swap 的使用量越少越好，否则说明实体内存不足

下半部分则为每个进程的资源使用情况，较重要的列为：PID、USER、PR、NI、%CPU、%MEM、TIME+、COMMAND，均可对应前文中的含义

top 界面中还可使用以下按键命令：

- ?：可用的按键命令
- P：以 CPU 的使用资源排序
- M：以内存的使用资源排序
- N：以 PID 排序
- T：以进程使用的 CPU 时间积累（TIME+）排序
- k：给予某个进程一个信号（signal）
- r：基于某个进程一个 nice 值
- q：离开

### pstree

`ps [<pid>]`：输出当前系统进程树（默认）或指定进程的子进程树，常用选项：

- `-A`：进程节点间以 ASCII 字符连接
- `-U`：进程节点间以 UTF-8 字符连接
- `-p`：显示每个进程的 PID
- `-u`：显示每个进程的所属用户名
- `-s <pid>`：显示指定进程的所有祖先进程

### kill

`kill [-s <signal>] <pid...>`：向指定 pid 进程发送信号（信号名或编号均可），后者默认为 TREM ，即按正常流程结束

- `-l`：输出所有可用信号

常用信号如下:

| 编号 | 名称    | 内容                                                           |
| :--- | :------ | :------------------------------------------------------------- |
| 1    | SIGHUP  | 启动已终止进程，后者可重新读取相关配置                         |
| 2    | SIGINT  | 相当于输入 ctrl-c 来中断一个进程                               |
| 9    | SIGKILL | 强制杀死进程，可能导致临时文件留存，如`.<filename>.swp`（vim） |
| 15   | SIGTERM | 按正常流程结束进程，对出问题的进程可能无效                     |
| 18   | SIGCONT | 启动已暂停（stopped）进程                                      |
| 19   | SIGSTOP | 暂停进程（不可被捕捉和忽略）                                   |
| 20   | SIGTSTP | 暂停进程（可被捕捉和忽略，相当于 Ctrl+Z），                    |

### killall

而 killall 指令可以通过名称来处理进程，其大致用法为：`killall [-ile] [command_name]`，相关参数解析如下：

- `-i`：interactive 的意思，互动式，在删除时会给予提示字符
- `-e`：exact 之意，即 command_name 参数需要和进程的指令完全一致（其实只需匹配前 15 个字符）
- `-i`：command_name 参数匹配时忽略大小写

<!-- TODO：关于指令的执行顺序（priority 与 nice 值） -->

## 系统状态观察

### uname

`uname`：输出系统与核心相关信息

- `-s`：仅输出系统核心名称
- `-r`：仅输出系统核心版本
- `-m`：仅输出系统硬件名称（如 i686 或 x86_64 等）
- `-p`：仅输出 CPU 类型
- `-i`：仅输出硬件平台（如 x86 等）
- `-a`：列出所有相关信息

### uptime

`uptime`：输出系统启动时长与工作负载，同 top 界面中的 uptime 行

### free

<!-- free [-b|k|m|g|h] [-t] [-s N -c N] -->

`free`：输出内存使用情况

- `-b`/`-k`/`-m`/`-g`/`-h`：将输出单位切换为 bytes、 Kb（默认）、Mb、Gb 或适宜可读形式（h）

- `-t`：输出附加 swap 使用情况

- `-s <seconds>`：每隔指定描述输出一次

- `-c <num>`：仅与`-s`搭配使用，输出指定次数后退出

输出结果中：

- total 为总量，used 为已被使用的量，free 为剩余可用的量

- 为加速存取效率，系统会充分利用剩余内存：shared/buffers/cached 被计算在已使用量中，系统忙碌时会被释放，因此最后还有一个 available（可用）数值

- 要注意的是 swap，不应被使用超过 20%，最好不被使用

<!-- TODO：其他指令（netstat、dmesg、vmstat） -->

## 系统服务

系统服务（service）也被称为 daemon，其相关进程常驻于内存中。服务名通常以`d`结尾，如 atd、crond 等（也有例外）

<!-- TODO：早期 Unix system V 版本通过 init 来管理服务 -->

### systemd 服务管理

systemd 将 daemon 执行脚本统称为一个服务单位（**unit**），后者依据功能可以分为不同的类型（type）。根据其服务配置脚本的后缀名即可分辨：

- `.service`：一般服务类型（service unit），也是最常见的。主要是系统服务包括服务器需要的本机及网络服务

- `.socket`：进程信息交换的插槽服务（socket unit），主要为 IPC（Inter-process communication）的传输信息插值文件（socket file）功能。此类服务通常监听信息传输的插槽文件，当有通过后者传来的连接服务请求时，就依据当时的状态将该请求传送至对应 daemon，若该 daemon 尚未启动，则将其启动后再传送。此类服务一般较少用到，因此开机时会稍微延迟启动，常用于本机服务（如软件图形界面通过 socket 进行信息交换）

- `.target`：操作环境类型服务（target unit），其实质是一群其他服务（unit）的集合

- `.mount/.automount`：文件系统挂载相关的服务（automount unit/mount unit），如来自网络的自动挂载、NFS 文件系统挂载等

- `.path`：侦测特定文件或目录类型（path unit），某些服务需要侦测特定的目录来提供消息队列服务，如打印服务

- `.timer`：循环执行的服务（timer unit）

服务配置脚本存放于以下目录中，按其执行优先级从低到高：

- `/usr/lib/systemd/system/`：主要的服务配置脚本存放目录
- `/run/systemd/system/`：存放系统运行过程中产生的服务配置脚本
- `/etc/systemd/system/`：存放着的会在系统开机时执行，一般都是链接，而实际配置脚本均是在/usr/lib/systemd/system/目录下；

### systemctl

systemd 提供了 systemctl 系列命令

- `systemctl [list-units|list-unit-files]`：列出系统中的所有服务

  - `list-units`：默认值，列出所有 loaded 状态（即 enable）且启动的 unit 及其相关属性，
  - `list-unit-files`：列出`/usr/lib/systemd/system`内的服务配置（所有预设状态下的），及其预设状态
  - `--all`：连同未启动的一起列出
  - `--type=<TYPE>`：列出指定类型的服务

- `systemctl status <unit>`：显示服务状态。常见状态如下：

  - `active（running）`：正在运行中
  - `active（exited）`：仅执行一次就已正常结束，如开机或挂载时执行的 quotaon 功能。用 bash 脚本写的小型服务通常属于该类型（无需常驻内存）
  - `active（waiting）`：正在运行中，但还须等待其他事件才能继续处理
  - `inactive`：未在运行中

  常见预设状态如下：

  - `enable`：将在开机时执行
  - `disable`：开机时不会执行
  - `static`：不可自行启动，而是需要其他服务来唤醒（相依属性的服务）
  - `mask`：无法被启动，因为已被强制注销（非删除）；可通过`systemctl unmask <unit>` 改回原本状态

其他服务管理命令：`systemctl <action> <unit>`，可用 action 如下：

- `start`：启动
- `stop`：关闭
- `restart`：重启，即先 stop 后再 start
- `reload`：在不关闭的前提下，重新载入配置
- `enable`：设为开机启动
- `disable`：静止开启启动
- `is-active`：检查是否正在运行
- `is-enabled`：检查是否开机启动

一些注意点：

- disable 一个服务实质就是在`/etc/systemd/system`中删除对应服务配置的链接，而 enable 则反之

- mask 的实质则为将该服务配置链接到`/dev/null`，使其无法被启动，即使存在相依服务（否则相依服务的启动仍会导致该服务被启动）

<!-- ### 通过 systemctl 管理操作环境类服务（target unit）

在所有服务中，与操作环境比较有关的是 target 类型服务；与操作环境相关性较高的 target 主要有：

- graphical.target：文字加图形界面，该项目包含了下文的 multi-user.target 项目
- multi-user.target：纯文字模式
- rescue.target：在无法使用 root 登入的情況下，systemd 在开机时会多加一个额外的暂时系统，与原本的系統無關。此时则可取得 root 的权限來维护系统；由于是额外系统，因此可能需要动用 chroot 的方式來取得原有的系统
- emergency.target：紧急处理系统的錯誤且还是需要使用 root 登入的情況下，若无法使用 rescue.target ，则可尝试该模式
- shutdown.target：关机流程
- getty.target：用于设定需要几个 tty 之类的，如果想要降低 tty 的数目，可以修改该服务的配置文件

systemctl 更改操作环境相关的指令为：**systemctl _command_ _unit_.target**，其中 command 解析如下：

- get-default：取得当前的操作环境
- set-default：将指定 target 设为预设的操作环境
- isolate：切换到指定 target 的操作环境（而无需重启）

注意切换操作环境（target）用的是 isolate，而非 service 对应的 start/stop/restart 操作；

另外 systemctl 还提供了数个简单指令供切换操作模式之用，大致如下：

- systemctl poweroff：系统关机
- systemctl reboot：重新开机
- systemctl suspend：进入暂停模式（将资料存于内存中并关闭大部分主机硬件，此模式唤醒速度较快）
- systemctl hibernate：进入休眠模式（将资料存于硬盘中后主机关机，在开机后恢复存储的系统状态，因此唤醒速度与硬盘速度有关）
- systemctl rescue：强制进度救援模式
- systemctl emergency：强制进入紧急救援模式 -->

<!-- ### 通过 systemctl 分析各服务间的相依性

使用 **systemctl list-dependencies [unit] [--reverse]** 来追踪一个 unit 的相依性：

- --reverse 选项则用于指定反向追踪；
- 而不带 unit 参数则默认指定为当前操作环境 target，即实际输出 default.target 的依赖树实质就是该 target 的依赖树（如 multi-user.target）； -->

---

## Shell 变量

shell 变量分为：普通变量、环境变量，后者一般用大写字符表示

- 承上，不同之处在于被双引号包围的，其中的\$...和\${...}内容仍会被视为变量并进行替换，而单引号内的则被视为纯字符
- 可用\将一些特殊符号如换行符、$、\、空白字符等转义成一般字符，如`myname=young\ penn`
- 在变量值中可用\``指令`\`或`$(指令)`的方式来引用并将其替换为其他指令的输出值，如`vsersion=$(uname -r)`
- 变量值是可串联的，如：`PATH="$PATh":/home/bin`或`PATH=${PATH}:/home/bin`，只要在语法上不会引起歧义
- 可以用 export 指令来使普通变量称为环境变量，如`export MYNAME`
- 承上，可以通过 bash/exit 指令来进入/离开子 shell，父 shell 中的普通变量无法在子 shell 中引用，可以通过将普通变量导出为环境变量来解决

可以使用 env 指令来列出当前系统中的环境变量，以下是一些常用系统变量：

- HISTSIZE：代表可容纳的已下达指令历史记录数量
- MAIL：代表邮件文件的存放位置
- PATH：代表执行文件的搜索路径，各个路径间以冒号（:）分隔，路径的顺序影响搜索的顺序
- LANG：代表当前操作系统的语系

除环境变量外还有一些重要的变量，且同样用大写形式来表示（在 linux 中，以大写形式表示的一般为系统内定需要的变量），可以通过 set 指令获取包括环境变量在内的所有 shell 变量；以下是一些列举：

- PS1 ：即所谓的命令提示符，其中可包含一些特殊意义的替换符：
  - \d：表示 “星期 月 日” 格式的日期
  - \H: 完整的主机名称
  - \h：取主机名称第一个词
  - \t：24 小时 HH:MM:SS 格式的时间
  - \T：12 小时 HH:MM:SS 格式的时间
  - \A：24 小时 HH:MM 格式的时间
  - \@：12 小时 am/pm 格式的时间
  - \u：当前用户的用户名
  - \v：当前 bash 的版本信息
  - \w：完整的工作目录
  - \W：当前工作目录的 basename
  - \\#: 已下达的指令计数
  - \$：提示字符，用户为 root 时显示 #，否则显示 $
    需要注意，PS1 的变量值建议用单引号（''）包围，否则部分特殊的替换符会被视为转义
- $ ：当前进程的 PID；比如，可以通过`echo $$`输出当前 shell 进程的 PID
- ? ：上一个指令（程序）的返回值
- OSTYPE、HOSTTYPE、MACHTYPE：主机与系统相关的信息

除了用等号给变量赋值外,也可以使用 read 指令读取键盘输入赋值给变量,该指令常被用在 shell script 中;该指令可以用 -p 选项后接字符来指定提示信息,也可以通过 -t 选项后接数字来指定输入等待的秒数

### 变量值的删除、取代与替换

除了通过赋值与再赋值来改变变量的值外，还可以通过其他方式来对变量的值做调整，以下是几个例子：

- 从左往右删除最短匹配，如：`path=${path#/*local/bin:}`
- 从左往右删除最长匹配，如：`path=${path##/*:}`
- 从右往左删除最短匹配，如：`path=${path%:*bin}`
- 从右往左删除最长匹配，如：`path=${path%%:*bin}`
- 替换变量值中的第一个匹配，如：`path=${path/sbin/SBIN}`
- 替换变量值中年的所有匹配，如：`path=${path//sbin/SBIN}`
- 若变量为未赋值，则以给定值为其赋值，如：`username=${username-root}`
- 若变量为未赋值或其值为空字符，则以给定值为其赋值，如：`username=${username:-root}`
- ...**待补充**

### 指令历史记录

history 指令用于列出下达过的指令历史记录, 一些用例:

- `history`: 默认状态下列出由环境变量 HISTSIZE 指定条数的历史记录, 也可以直接后接数字选项来指定条数
- `history -w [filepath]`: 向指定文件写入当前的历史记录,如未指定则使用默认文件 ~/.bash_history
- 可以直接通过`!n`指令来调用历史记录中的第 n 条指令
- `!!`: 执行上一条指令
- `![comm]`: 执行历史记录中最近的一条以 comm 为开头的指令
- **关于同一用户开启多个 bash 执行的指令历史问题: TODO**

### Shell 配置文件

首先需要了解 login shell 和 non-login shell 的不同之处：

- login shell：取得 bash 时需要完整的登录流程的 shell，举例：由 tty1~tty6 登入，需要使用者的账号与密码的；login shell 会读取的配置：/etc/profile（不太建议修改）、~/.bash_profile 或 ~/.bash_login 或 ~/.profile（用户个人配置）
- none-login shell：取得 shell 时不需要重复登录的流程，例如在原本 bash 环境下使用 bash 指令新开一个子 shell；

从配置文件的角度：

- /etc/profile（login shell 专属）：也是每个用户登入 bash 时一定会读取的，作为整体配置文件（若要为所有用户配置整体环境，则可修改此处）；主要作用：
  - 根据用户 UID 设定相关（环境）变量如：PATH、MAIL、USER、HOSTNAME、HISTSIZE
  - 读取其他外部配置文件，如：/etc/profile.d/\*.sh、/etc/locale.conf、/usr/share/bash-completion/completion/\* 等
- ~/.bash_profile（login shell 专属）：如不存在则从 ~/.bash_login、~/.profile 按序读取其中之一，作为用户个人配置文件；主要作用：
  - 将用户 home 目录下的 bin 目录加入到 PATH 环境变量中去
  - 若 ~/.bashrc 文件存在则使用 souce 指令（或.）将其读取
- ~/.bashrc：主要设置了一些命令别名并读取了配置文件 /etc/bashrc

以上的读取均使用了指令 source，使用该指令（或.）可以将配置文件的设定读入当前的 shell 环境中，无需重新登录

### bash 通配符（wildcard）

- **\***：代表 0 到无穷多个任意字符
- **?**：代表 1 个任意字符
- **[...]**：代表一个方括号内的任意字符
- **[ - ]**：代表一个在编码顺序范围内的任意字符
- **[^...]**：代表一个非方括号内所列出的任意字符

### 输出重定向

**标准输出（STDOUT）**:执行指令正确时输出的流
**标准错误输出（STDERR）**：执行指令失败时输出的流
默认情况下此二者都会被输出到屏幕上，但也可以通过某些机制将二者分开，分别输出到其他文件（文本文件或设备）中去，这就是输出重定向的意义

- 标准输入（stdin）：代码为 0，重定向符号位 < 或 <<，前者为覆盖后者为追加，以下同理
- 标准输出（stdout）：代码为 1， > 或 >>
- 标准错误输出（stderr）：代码为 0， 2> 或 2>>
- 标准输出和标准错误输出重定向（到同一文件）：`> [path] 2>&1` 或 `>> [path] 2>&1`
- 承上，另一种更简单的符号：&> 或 &>>

一个典型的例子是在以非 root 身份调用 find 指令时，由于权限原因，输出信息中会同时包含匹配的文件和权限不足的提示，即对应标准输出和标准错误输出，此时便可将二者分别重定向，如：  
`find /etc -name .bashrc >right 2>wrong`

若想把标准错误输出并入标准输出且重定向到同一个文件，则可以使用 `2>&1` 或 `&>` 的方式；同上例，如：  
`find /etc -name .bashrc > ./all 2>&1` 或 `find /etc -name .bashrc &> ./all`  
反之，若要将标准输出并入标准错误输出且重定向，则使用 `1>&2`，如 `find /etc -name .bashrc 2> ./all 1>&2`

可以通过将标准输出或标准错误输出重定向到路径 /dev/null 来将其丢弃

标准输出重定向的另一个用例是将 cat 指令对标准输入（stdin）的输出（因为 cat 指令在不附加文件路径参数或该参数为 - 时会从标准输入即键盘输入中读取并输出数据）重定向到文件中；如:  
`cat > ./inputfile`  
此外还可以借助 << 符号来指定结束字符；承上例，若是希望当键盘输入字符 eof 时结束此次输入(而非 ctrl + d)，则可以：  
`cat > ./inputfile << "eof"`

承上，若是希望将原本键盘输入的资料改由文件内容来取代，则可以借助标准输入重定向：  
`cat > ./inputfile < ~/.bashrc`

### 指令的逻辑执行

- 连续指令下达：`[expression] ; [expression]`, 将两个指令用分号隔开即可让此二者分先后同步执行
- 前一指令被正确执行后才执行后一指令：`[expression] && [expression]`
- 前一指令执行出错后才执行后一指令（后备）：`[expression] || [expression]`

一个常见的用例是希望先检查某目录是否存在，存在则在此目录新建文件，因而可使用 &&，如：  
`ls ./abc && touch ./abc/hehe`  
另一方面，若是希望在某目录不存在时先新建该目录，则使用 \|\|：  
`ls ./abc || mkdir ./abc`  
综上，二者结合：`ls ./abc || mkdir ./abc && touch ./abc/hehe`（注意：若是目录不存在，则可能会输出错误信息，但结果仍是符合预期的）

另一种是属于判断的情况，若是希望检查某目录是否存在，存在则输出“exist”，反之则输出“not exist”，则：  
`ls ./abc && echo 'exist' || echo 'not exist'`
此种情况下，基本是固定的形如：`command1 && command2 || command3`，顺序不能乱

### 命令管道（pipe）

可以借助管道符号 |，来实现指令的串联，即前一个指令接收后一个指令的输出值并继续执行；命令管道有以下需要注意的：

- 命令管道中后一个指令仅能接收前一个指令的标准输出，对标准错误输出则会忽略
- 命令管道中的指令必须要能够接收标准输入

承上，能够接收并处理标准输入并将结果标准输出的指令，可以称之为管道命令；。一些管道命令列举：[cut](/devops/cmd#cut)、[grep](/devops/cmd#grep)、[sort](/devops/cmd#sort)、[uniq](/devops/cmd#uniq)、[wc](/devops/cmd#wc)、[tee](/devops/cmd#tee)、[split](/devops/cmd#split)、[tr](/devops/cmd#tr)、[xargs](/devops/cmd#xargs)

<!-- - col 指令用于在每行过滤掉控制字符，如反向或半反向换行符，Tab 符等（避免在转换为纯文本时出现乱码或特殊符号）；常见的，形如：`col -x`用于将 Tab 符替换为空格符，这样使用`cat -A`输出内容时不会出现^I -->

- join 指令用于将两份文件内容（有一份可以来自标准输入）按行合并并标准输出；合并流程为先将两份文件的每行按指定分隔符（只能为单个字符，默认为空格符，同 cut）分段，默认取第一段为相同段（可以通过-1、-2 选项后接数字来为第一、第二份文件单端指定）并前置，后面分别接第一、第二份文件在该行的剩余部分；具体示例如下：  
  `join -t ':' -1 4 /etc/passwd -2 3 /etc/group`

- paste 指令用于将两份文件内容（有一份可以来自标准输入）按行连接并标准输出；可以通过 -d 选项指定每行中的分隔符，默认为 Tab 符；列举：`paste /etc/passwd /etc/shadow`

- expand 指令用于将 tab 符替换为空格符（tab 符在转换为纯文本输出时会显示为^I）, 默认一个 tab 符=8 个空格符，也可以通过-t 选项后接数字来指定；如：  
  `grep '^MANPATH' /etc/man_db.conf | head -n 3 | expand -t 6 - | cat -A`

### shell 正则表达式

shell 正则的语法与 JavaScript 正则的语法基本一致,差异主要在于:

1. shell 正则分为基本（basic）正则和延伸（extended）正则（可以通过 grep -E 或 egrep 指令来开启支持），差异在于基本正则中的 ? + ( ) { | 不会被视为特殊字符，因此要触发其特殊含义需要先转义（与 JavaScript 相反）；而延伸正则相反，不过需要注意部分版本的延伸正则仍不视 { 为特殊字符
2. shell 正则中的元字符表示方式有异，不存在诸如\w \s \d 之类的表示法，而采用以下方式：
   - `[:alnum:]`：代表大小写英文字母及数字，即`[0-9a-zA-Z]`
   - `[:alpha:]`：代表大小写英文字母，即`[a-zA-Z]`
   - `[:blank:]`：代表空格键或 Tab 键字符
   - `[:cntrl:]`：代表键盘上的控制按键，即 CR、LF、Tab、Del 等
   - `[:digit:]`：代表数字，即`[0-9]`
   - `[:graph:]`：代表除空白字符（空格键或 Tab 键字符）外的其余任意字符
   - `[:lower:]`：代表小写字母，即`[a-z]`
   - `[:upper:]`：代表大写字母，即`[A-Z]`
   - `[:print:]`：代表任意可被打印出来的字符
   - `[:punct:]`：代表标点符号，即 : " ' ? ! ; : # $ 等
   - `[:space:]`：代表任何会产生空白的字符，包括空白键、Tab 键、CR 等
   - `[:xdigit:]`：代表 16 进制的数字类型，因此即 `[0-9A-Fa-f]`

支持正则的指令除了已介绍过的 grep 外，较常用的还有 sed 和 awk

### 文件对比工具

diff 指令可以用于按行对比两个文本文件或两个目录之间的差异；其大致语法为：`diff [-bBi] oldFile newFile`，其中 oldFile 和 newFile 其中之一可以用"-"替代，则将改由标准输入中读取内容；对比文本内容是最常用到的情况，此时得到的是 newFile 相对于 oldFile 的增量差异；较常用的选项列举如下：

- -b：忽略一行中多个连续空白符引起的差异
- -B：忽略多出空行而引起的差异
- -i：忽略大小写因此的差异
- -u：在比较结果中输出上下文的行，后可接数字显式指定行数，默认为 3
- diff 指令还能够生成 patch 文件，如：`diff -Nur file.old file.new > file.patch`

承上文，patch 指令可以接收 diff 指令生成的 patch 文件以将旧文件更新：**TODO**

cmp 指令相比于 diff 用到的较少，相对于 diff 的按行比较，cmp 采用按位比较的形式，因此能够用于比较二进制文件（binary file）

### 预备打印文件命令：pr

**TODO**

### 使用 ulimit 指令限制用户占用的系统资源

**TODO**

### bash 的进入提示讯息

**TODO**

### bash 的环境配置文件

**TODO**

### 终端机的环境设定

**TODO**

## Shell Script

shell 脚本文件可以通过两种方式执行：

**直接执行：**其实质是在一个子 bash 内执行脚本，而父 bash 在此期间处于 sleep 状态，执行结束后退出子 bash 重返父 bash；因而脚本在执行期间设置的变量将无法在父 bash 内被访问到；而直接执行又有以下两种方式:

- 只输入 shell 脚本名称（带路径），前提是拥有该脚本的 rx 权限
- 使用 bash 或 shell 指令并后接脚本名称，只需要拥有脚本的 x 权限

**使用 source 指令执行：**脚本会直接在父 bash（当前 bash）内执行，因而执行期间设置的变量都会保留；也是因此若想在不退出系统的情况下让 ~/.bashrc 中的设定生效，应使用 `source ~/.bashrc` 而非 `bash ~/.bashrc`

为保证正确执行，脚本的第一行固定为 `#!/bin/bash`

### Shell 数值计算

shell 支持 + - \* / % 等运算，依据处理数字是否为整数，又可分为两类方式：

**整数计算**:

- 可以使用 $((...)) 的方式，如：`echo $((9*9))`、`var=$((13%3))`等
- 也可以使用 declare -i ... 的方式， 如 `declare -i total=${num1}*${num2}`

**浮点数计算**
借助 bc 指令来实现浮点数计算，如 `echo "9.9*2.0" | bc`，bc 指令有以下注意点：

- 可以直接输入 bc 指令来进入交互模式，此时可以通过指定-q 选项来去除欢迎信息
- 也可以通过管道符来接收标准输入作为参数，进行直接运算
- 通过设置内置 scale 变量来设定小数点后保留数字（默认情况下不保留小数点后数字),如 `echo "scale=3; 13/3" | bc"`
- 可以通过 -l 选项来启用标准数学库，一个常用的用途是计算 Pi，如：`echo "scale=300; 4*a(1)" | bc -l`

### Shell 条件判断

除了使用指令返回码配合&&及||实现条件语句，诸如：`ls [filepath] 2>/dev/null && echo 'exist' || echo 'Not exist'` 外，更常用的方式是使用 test 指令；test 指令不会产生标准输出，但可以通过 $? 获取其返回码，为 0 即表示 true，否则为 false；以下是其选项说明：

- **判断文件类型**
  - -e：测试文件是否存在，如`test -e [filepath]`
  - -f：测试文件是否存在且为普通文件
  - -d：测试文件是否存在且为目录
  - -b：测试文件是否存在且为块设备（block device）
  - -c：测试文件是否存在且为字节设备（character device）
  - -S：测试文件是否存在且为 Socket
  - -p：测试文件是否存在且为 FIFO（pipe）
  - -L：测试文件是否存在且为链接
- **判断文件权限**
  - -r：测试文件是否存在且具有可读权限
  - -w：测试文件是否存在且具有可写权限
  - -x：测试文件是否存在且具有可执行权限
  - -u：测试文件是否存在且具有 SUID 属性
  - -g：测试文件是否存在且具有 SGID 属性
  - -k：测试文件是否存在且具有 Sticky bit 属性
  - -s：测试文件是否存在且为非空文件
- **比较两个文件**
  - -nt：newer than，判断 file1 是否比 file2 新，如`test [file1] -nt [file2]`
  - -ot：older than，判断 file1 是否比 file2 旧
  - -nt：判断 file1 是否比 file2 是否为同一文件，即两个文件名是否指向同一个 inode，主要用在硬链接（hard link）的判断上
- **整数比较**
  - -eq：equal，判断两整数是否相等，如`test [n1] -eq [n2]`
  - -ne：not equal，判断两整数是否不相等
  - -gt：greater than，判断 n1 是否大于 n2
  - -lt：less than，判断 n1 是否小于 n2
  - -ge：greater than or equal，判断大于等于
  - -le：less than or equal，判断小于等于
- **判断字符串**
  - -z：判断字符串是否为空，如 `test -z [str]`
  - -n：判断字符串是否为非空，如 `test -n [str]`；注：此选项可省略，即其为 test 指令的默认动作
  - 判断两字符串是否相等：`test [str1] == [str2]`；注：双等号左右需留空格，下同理
  - 判断两字符串是否不相等：`test [str1] != [str2]`
- **多重条件判断**
  - -a：and，用于串联两个条件语句，彼此都成立时才为 true，如 `test -e [file1] -a -e [file2] -a -e [file3]`
  - -o：or，用于串联两个条件语句，彼此只要有一个成立就为 true
  - !：表示取反判断，如 `test ! -e [file]`，表示当文件不存在时才返回 true

除了使用 test 指令，也可以将其省略而用方括号（[]）包裹的条件语句来代替；当然为了避免歧义（方括号在通配符和正则语句中都有用到），方括号内的左右侧都需要留有空白，比如 `[ "$HOME" == "$MAIL" ]`; **中括号判断语句常用于逻辑表达式中**；以下是注意点的总结:

- 方括号内所有的成员都需要有空白符来分隔
- 方括号内所有的变量最好都包裹在双引号内，如 `[ "${name}" == "penn" ]`
- 方括号内所有的常量最好都包裹在单/双引号内

### Shell Script 预设变量

shell 脚本中支持以下内置参数：

- $0：表示执行脚本的文件路径
- $1、$2、$3...：执行脚本时传入的第 1、2、3...个参数
- $#：执行脚本时传入的参数个数
- $@：表示"$1" "$2" "$3"...，即每个参数都是独立的
- $\*：表示"$1c$2c$3..."，其中 c 为分隔字符，预设为空格符

注意：$@ 和 $\* 是不同的，一般情况下 $@ 用到的较多；另外 $@ 和 "$@" 也是不同的，若输入的参数中存在有带双引号的，建议在脚本中使用 "$@"
此外,与之相关的有 shift 指令, 该指令后接数字用于从左往右削减参数；如在脚本中调用`shift 2`后，再次调用 `echo $#`后得到的参数总数将减少 2，调用`echo $1`后将得到原本的第 3 个参数

### Shell Script 逻辑语句

利用 && 与 || 通常只能处理较为简单的情况，更复杂的情况往往需要借助逻辑语句来解决

- if ... then 语句

  - 单层条件判断，形如：

    ```bash
      if [ ...条件判断式... ]; then
          ...当条件判断成立时执行... ;
      fi
    ```

  - 多重条件判断，形如：

    ```bash
      if [ ...条件判断式... ]; then
        ...当条件判断成立时执行... ;
      else
        ...当条件判断不成立时执行... ;
      fi
    ```

    以及：

    ```bash
      if [ ...条件判断语式一... ]; then
        ...当条件判断式一成立时执行... ;
      elif [ ...条件判断式二... ]; then
        ...当条件判断式二成立时执行... ；
      else
        ...当以上条件判断式均不成立时执行... ;
      fi
    ```

    另外值得注意的是，当多个条件需要判断时，除了在同一个方括号内并用 -a 或 -o 连接相应判断语句外；还可以写入多个方括号中并用 && 或 || 来连接，其中 && 代表 AND，|| 代表 OR，如：  
     `[ "${yn}" == "Y" -o "${yn}" == "y" ]` 可以替换为 `[ "${yn}" == "Y" ] || [ "${yn}" == "y" ]`

- case ... esac 语句，其语法形如：

  ```bash
    case $变量名 in
    "...变量值一...")
      ...变量与值一匹配时执行...
      ;;
    "...变量值二...")
      ...变量与值二匹配时执行...
      ;;
    *)
      ...以上均不匹配时执行...
      ;;
    esac
  ```

### Shell Script 函数

Shell 脚本同样可以定义函数，形式如下：

```bash
function ...函数名... () {
  ...函数内容...
}
```

函数的调用方式同指令，直接输入函数名调用，不需要加小括号；且需要注意：

- 函数需要定义在脚本的最前面，即函数需要先定义再执行
- 函数有其独立的预设变量（注意不是普通变量）；即可以给函数传参，方式与脚本传参一致，而在函数体内部也同样可以以$1，$2...的方式取得，注意该值不可与函数外的同名值混淆

### Shell Script 循环

Shell 脚本中包含以下几种循环：

- **while/until 循环（条件循环）**；其中 while 循环其意为在给定条件成立时进行循环，形式如下：

  ```bash
  while [ ...condition... ]
  do
    ...expression...
  done
  ```

  而 until 循环则恰恰相反，其意为在给定条件不成立时才进行循环，形式如下：

  ```bash
  until [ ...condition... ]
  do
    ...expression...
  done
  ```

- **for ... in 循环（迭代循环）**；for ... in 循环通常用于迭代由空白符分隔的字串，每次循环处理一个迭代值，其形式如下：

  ```bash
  for 变量名 in 变量值1 变量值2 变量值3 ...
  do
    ...
  done
  ```

  常与 for...in 循环搭配使用的有 seq 指令，用于构造出连续可迭代的字串，例如：`seq 0 100`，得到 1 到 100 间的连续整数；而 `seq 0 10 100`，得到的是 0 到 100 间相隔 10 的整数；  
  当然，seq 命令只能构建整数字串，更通用的方式是理由 bash 的内建机制：`{start..end}`（注：中间不能有空格），其可以用于构建连续的数字、字符字串，例如：`echo {1..10}` 以及 `echo {a..g}`

- **for 循环**；该种循环适合含有数值计数的操作，其形式如下：

  ```bash
  for ((初始值;限制值;步骤语句))
  do
    ...
  done
  ```

  双括号内的步骤解释如下：

  - 初始值：某个变量在循环中的起始值，如：`i=1`
  - 限制值：当该变量的值在限制值的范围内，则继续执行循环，如：`i<=100`
  - 步骤语句：每次循环执行完后，该变量的变化：`i=i+1`

### Shell Script Debug

利用 sh 指令不仅可以直接执行脚本，也可以用于检查语法错误或列出执行过程，相关选项如下：

- -n：不执行脚本，而是检查语法问题
- -x：执行脚本，并列出执行过程

## bash 环境下的工作管理（job control）

在 bash 环境中的工作管理（job control），实质是管理自身的子进程，因而无法涉及跨 tty 环境的管理，而当 bash 退出后，其中的工作也将全部中断；  
此外，首先需要了解 bash 中出现提示字符可供操作的环境称为前台（foreground），而与之相对的则称为后台（background），工作（进程）可以在后台中暂停（stop）或运行（running）；当然后台中的工作无法与使用者互动，举例来说：vim 无法在背景中运行（running）；以下是 bash 中工作管理的一些限制：

- 管理的工作必须是该 bash 的子进程
- 只能在前台（foreground）中控制与下达指令
- 在后台（background）的工作无法通过 ctrl+c 去终止，但可用 bg/fg 指令去做切换
- 在后台（background）的工作不能等待来自终端（terminal）的输入

以下是一些工作管理的措施：

- **直接将指令丢到后台执行**：在输入指令的最后加上&符号即可，而后 bash 会返回该指令的工作号码（job number）及其对应进程的 PID。此时该工作会在后台被执行，待执行完成后任意触发输入，bash 会输出完成的提示；需要注意的是后台工作的标准（错误）输出仍将被打印在屏幕上，因而通常需要配合使用输出重定向；例如：  
  `tar -zpcvf /tmp/etc.tar.gz /etc &>/tmp/log &`
- **将当前工作丢到后台中暂停**：使用 ctrl + z 即可，此时 bash 会切换到前台环境并输出 `[N]+ Stopped ...`，其中 [N] 表示是第 N 个工作，而 + 表示最近一个被丢入后台的工作（fg 指令默认会取用该工作），而 Stopped 则代表该工作处于暂停状态
- **观察后台工作的状态**：使用 jobs 指令，该指令会列出所有正在后台的工作，前面有+号的表示最近放入后台的（也是 fg 指令默认会拿到前台的），而有-号的表示倒数第二个被放入后台的；jobs 指令可选选项如下：
  - -l：同时列出工作的 PID
  - -r：仅列出后台处于运行（running）状态的工作
  - -s：仅列出后台处于暂停（stopped）状态的工作
- **将后台的工作拿到前台**：使用 fg 指令即可，该指令默认取出前面有+号的工作，也可后接 [%]jobnumber 的参数形式指定拿取的工作，如 `fg %2`，其中%号是可选的；另外可以通过 `fg -` 取出前面带-号的工作
- **运行后台暂停的工作**：使用 bg 指令并后接 [%]jobnumber 的参数形式，如 `bg %3`；再使用 jobs 可以观察到对应工作后面多了一个&号，表示该工作是运行中的
- **移除后台工作**：用 kill 指令向该工作发送一个信号（signal），其语法大致为 `kill [-signal] [%jobnumber|pid]`，即可以后接 pid 或带%前缀的 jobnumber，如 `kill -9 %2`；可以先通过 `kill -l` 查询该指令能够使用的信号；以下是一些常用信号列举：
  - -1：重新读取一次参数的配置（类似 reload）
  - -2：代表执行与键入 ctrl+c 相同的动作
  - -9：立即强制删除一个工作
  - -15：以正常的程序终止一项工作，也是默认值

### 工作的离线管理

由于 bash 中的工作会在 bash 进程退出后中断，因而长时间工作可以通过以下方式处理：

- 可以通过前文中提到的 at 指令来执行该工作
- 可以通过 nohup 指令来执行工作，例如：`nohup ./sleep500.sh &`，此时会返回 `nohup: ignoring input and appending output to nohup.out` 来告知标准（错误）输出会被重定向到当前工作目录的 nohup.out 文件中，而该工作会在系统后台中被执行而与 bash 无关；注意 nohup 执行的工作不支持 bash 内建的指令！
